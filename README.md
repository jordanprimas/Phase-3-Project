# Phase 3 CLI+ORM Project Template

## Introduction
A database for managing books and their libraries.

## Requirements For Generating Your Environment

* Have python installed 

## Repo URL 
[Repository link](https://github.com/jordanprimas/python-p3-conditional-statements.git)

## Interacting With The CLI
`cli.py` is a simple CLI that interacts with a library management database. 
When the user runs the script a menu of options will appear in the terminal. The script is a loop and the user will indicate they want to exit using option 0. There are six options that allow for book management starting with `list_books()` which lists all the books in the database. `find_book_by_title()` allows the user to get a book in the database using its title. `find_book_by_id()` allows the user to find a book in the database using its id. Next there is `create_book()` which creates a new book row in the database. It also has the appropriate type validation and will raise an error if the data type input is incorrect. `update_book()` finds a book in the database using its id and then updates any of the book's attributes according to the input data. This method will also perform type checks against the input data. `delete_book()` prompts the user to input an id and then deletes the respective book from the database. Finally there is `find_book_library()` which will prompt the user to enter the id of a book and then returns the library object that owns that book. 
Next there are functions for managing the libraries. `list_libraries()` allows the user to get all the libraries in the database. Next there is `find_library_by_name()` and `find_library_by_id()` which will allow the user to find a library in the database by inputting its name or id respectively. `create_library()` will prompt the user to input data for a new library and add it to the database if the data types don't raise an error when validating. `update_library()` finds a library in the database using its id and then updates any of the library's attributes according to the input data. `delete_library()` prompts the user to input an id and will delete the corresponding library from the database. Finally `list_library_books()` allows the user to find all books in a library by intputting the library's id. 
Many of the methods above include type validation to ensure that the correct data type is being passed to the database. When troubleshooting recall that this may be the cause of a ValueError you receive when interacting with the database.  

### Interacting With The Models
This project contains two classes with a two way one-to-many relationship model. 

The `book.py` file contains the `Book` class which is responsible for all books within the database. `Book` is initialized with `title`, `author`, `year`, and `library_id`attributes. The `__repr__()` magic method then takes an object and returns a readble string representation. The `title()`,`author()`, and `year()` properties then ensure the validity of the attributes values and raise an error if they are not. The `library_id()` property will also check for the validity of its attribute ensuring that the `library_id` matches the id of a library within the database. The `create_table()` classmethod is used to create a new book table in the database if it doesn't already exist. This table will have all of the previously defined attributes as columns. The `drop_table()` classmethod is used to delete the book table from the database. `save()` will allow the user to save the attributes of a new instance to a book table row with a unique id. `create()` is a classmethod that allows the user create a new book instance and save it to the database in one step. `update()` and `delete()` methods update and delete a book from the database respectivly using its id. `instance_from_db()` retrieves the newest instance from the class variable `all` or if the instance isn't found it updates `all` to contain the newest instance and then returns it. The `get_all()` classmethod queries the database and returns all the books then passes each one to `instance_from_db()` to be formatted. Next the `find_by_title` and `find_by_id` classmethods query the database and return one book matching the input title or id respectivly. Finally `library()` queries the database and returns library with a matching `id` to the instance's `library_id`. 

The `library.py` file contains the `Library` class which is responsible for all libraries within the database. `Library` is initialized with `name` and `zip_code` attributes. The `__repr__()` magic method then takes an object and returns a readble string representation. The `name()` and `zip_code()` properties then ensure the validity of the attributes values and raise an error if they are not. The `create_table()` classmethod is used to create a new library table in the database if it doesn't already exist. This table will have all of the previously defined attributes as columns. The `drop_table()` classmethod is used to delete the library table from the database. `save()` will allow the user to save the attributes of a new instance to a library table row with a unique id. `create()` is a classmethod that allows the user create a new library instance and save it to the database in one step. `update()` and `delete()` methods update and delete a library from the database respectivly using its `id`. `instance_from_db()` retrieves the newest instance from the class variable `all` or if the instance isn't found it updates `all` to contain the newest instance and then returns it. The `get_all()` classmethod queries the database and returns all the libraries then passes each one to `instance_from_db()` to be formatted. Next the `find_by_title` and `find_by_id` classmethods query the database and return one library matching the input title or `id `respectivly. Finally `books()` queries the database and returns all the books with a matching `library_id` to the instance's `id`. 


## Resources

- [Markdown Cheat Sheet](https://www.markdownguide.org/cheat-sheet/)
# Phase-3-Project
